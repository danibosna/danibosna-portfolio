import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, setHttpStatus } from '@sentry/core';
import { getActiveSpan, runWithAsyncContext, continueTrace, getCurrentScope, startSpan, getClient, captureException } from '@sentry/node';
import { addNonEnumerableProperty, stripUrlQueryAndFragment, objectify } from '@sentry/utils';
import { getTracingMetaTags } from './meta.js';

function sendErrorToSentry(e) {
  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can
  // store a seen flag on it.
  const objectifiedErr = objectify(e);

  captureException(objectifiedErr, {
    mechanism: {
      type: 'astro',
      handled: false,
      data: {
        function: 'astroMiddleware',
      },
    },
  });

  return objectifiedErr;
}

const handleRequest = options => {
  const handlerOptions = {
    trackClientIp: false,
    trackHeaders: false,
    ...options,
  };

  return async (ctx, next) => {
    // if there is an active span, we know that this handle call is nested and hence
    // we don't create a new domain for it. If we created one, nested server calls would
    // create new transactions instead of adding a child span to the currently active span.
    if (getActiveSpan()) {
      return instrumentRequest(ctx, next, handlerOptions);
    }
    return runWithAsyncContext(() => {
      return instrumentRequest(ctx, next, handlerOptions);
    });
  };
};

async function instrumentRequest(
  ctx,
  next,
  options,
) {
  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)
  const locals = ctx.locals ;
  if (locals && locals.__sentry_wrapped__) {
    return next();
  }
  addNonEnumerableProperty(locals, '__sentry_wrapped__', true);

  const { method, headers } = ctx.request;

  return continueTrace(
    {
      sentryTrace: headers.get('sentry-trace') || undefined,
      baggage: headers.get('baggage'),
    },
    async () => {
      const allHeaders = {};

      if (options.trackHeaders) {
        headers.forEach((value, key) => {
          allHeaders[key] = value;
        });
      }

      if (options.trackClientIp) {
        getCurrentScope().setUser({ ip_address: ctx.clientAddress });
      }

      try {
        const interpolatedRoute = interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params);
        const source = interpolatedRoute ? 'route' : 'url';
        // storing res in a variable instead of directly returning is necessary to
        // invoke the catch block if next() throws
        const res = await startSpan(
          {
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',
            },
            name: `${method} ${interpolatedRoute || ctx.url.pathname}`,
            op: 'http.server',
            status: 'ok',
            data: {
              method,
              url: stripUrlQueryAndFragment(ctx.url.href),
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
              ...(ctx.url.search && { 'http.query': ctx.url.search }),
              ...(ctx.url.hash && { 'http.fragment': ctx.url.hash }),
              ...(options.trackHeaders && { headers: allHeaders }),
            },
          },
          async span => {
            const originalResponse = await next();

            if (span && originalResponse.status) {
              setHttpStatus(span, originalResponse.status);
            }

            const scope = getCurrentScope();
            const client = getClient();
            const contentType = originalResponse.headers.get('content-type');

            const isPageloadRequest = contentType && contentType.startsWith('text/html');
            if (!isPageloadRequest || !client) {
              return originalResponse;
            }

            // Type case necessary b/c the body's ReadableStream type doesn't include
            // the async iterator that is actually available in Node
            // We later on use the async iterator to read the body chunks
            // see https://github.com/microsoft/TypeScript/issues/39051
            const originalBody = originalResponse.body ;
            if (!originalBody) {
              return originalResponse;
            }

            const decoder = new TextDecoder();

            const newResponseStream = new ReadableStream({
              start: async controller => {
                for await (const chunk of originalBody) {
                  const html = typeof chunk === 'string' ? chunk : decoder.decode(chunk, { stream: true });
                  const modifiedHtml = addMetaTagToHead(html, scope, client, span);
                  controller.enqueue(new TextEncoder().encode(modifiedHtml));
                }
                controller.close();
              },
            });

            return new Response(newResponseStream, originalResponse);
          },
        );
        return res;
      } catch (e) {
        sendErrorToSentry(e);
        throw e;
      }
      // TODO: flush if serverless (first extract function)
    },
  );
}

/**
 * This function optimistically assumes that the HTML coming in chunks will not be split
 * within the <head> tag. If this still happens, we simply won't replace anything.
 */
function addMetaTagToHead(htmlChunk, scope, client, span) {
  if (typeof htmlChunk !== 'string') {
    return htmlChunk;
  }

  const { sentryTrace, baggage } = getTracingMetaTags(span, scope, client);
  const content = `<head>\n${sentryTrace}\n${baggage}\n`;
  return htmlChunk.replace('<head>', content);
}

/**
 * Interpolates the route from the URL and the passed params.
 * Best we can do to get a route name instead of a raw URL.
 *
 * exported for testing
 *
 * @param rawUrlPathname - The raw URL pathname, e.g. '/users/123/details'
 * @param params - The params object, e.g. `{ userId: '123' }`
 *
 * @returns The interpolated route, e.g. '/users/[userId]/details'
 */
function interpolateRouteFromUrlAndParams(
  rawUrlPathname,
  params,
) {
  const decodedUrlPathname = tryDecodeUrl(rawUrlPathname);
  if (!decodedUrlPathname) {
    return undefined;
  }

  // Invert params map so that the param values are the keys
  // differentiate between rest params spanning multiple url segments
  // and normal, single-segment params.
  const valuesToMultiSegmentParams = {};
  const valuesToParams = {};
  Object.entries(params).forEach(([key, value]) => {
    if (!value) {
      return;
    }
    if (value.includes('/')) {
      valuesToMultiSegmentParams[value] = key;
      return;
    }
    valuesToParams[value] = key;
  });

  function replaceWithParamName(segment) {
    const param = valuesToParams[segment];
    if (param) {
      return `[${param}]`;
    }
    return segment;
  }

  // before we match single-segment params, we first replace multi-segment params
  const urlWithReplacedMultiSegmentParams = Object.keys(valuesToMultiSegmentParams).reduce((acc, key) => {
    return acc.replace(key, `[${valuesToMultiSegmentParams[key]}]`);
  }, decodedUrlPathname);

  return urlWithReplacedMultiSegmentParams
    .split('/')
    .map(segment => {
      if (!segment) {
        return '';
      }

      if (valuesToParams[segment]) {
        return replaceWithParamName(segment);
      }

      // astro permits multiple params in a single path segment, e.g. /[foo]-[bar]/
      const segmentParts = segment.split('-');
      if (segmentParts.length > 1) {
        return segmentParts.map(part => replaceWithParamName(part)).join('-');
      }

      return segment;
    })
    .join('/');
}

function tryDecodeUrl(url) {
  try {
    return decodeURI(url);
  } catch {
    return undefined;
  }
}

export { handleRequest, interpolateRouteFromUrlAndParams };
//# sourceMappingURL=middleware.js.map
