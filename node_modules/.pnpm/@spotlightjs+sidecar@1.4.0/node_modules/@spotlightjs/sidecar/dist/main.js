var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { createWriteStream, readFile } from "fs";
import { createServer, get } from "http";
import { extname, join } from "path";
import { createGunzip, createInflate } from "zlib";
const defaultLogger = {
  info: (message) => console.log("ðŸ”Ž [Spotlight]", message),
  warn: (message) => console.warn("ðŸ”Ž [Spotlight]", message),
  error: (message) => console.error("ðŸ”Ž [Spotlight]", message),
  debug: (message) => debugEnabled && console.debug("ðŸ”Ž [Spotlight]", message)
};
let injectedLogger = void 0;
let debugEnabled = false;
function activateLogger(logger2) {
  injectedLogger = logger2;
}
function enableDebugLogging(debug) {
  debugEnabled = debug;
}
const logger = {
  info: (message) => (injectedLogger || defaultLogger).info(message),
  warn: (message) => (injectedLogger || defaultLogger).warn(message),
  error: (message) => (injectedLogger || defaultLogger).error(message),
  debug: (message) => (injectedLogger || defaultLogger).debug(message)
};
class MessageBuffer {
  constructor(size = 100) {
    __publicField(this, "size");
    __publicField(this, "items");
    __publicField(this, "writePos", 0);
    __publicField(this, "head", 0);
    __publicField(this, "timeout", 10);
    __publicField(this, "readers", /* @__PURE__ */ new Map());
    this.size = size;
    this.items = new Array(size);
  }
  put(item) {
    const curTime = (/* @__PURE__ */ new Date()).getTime();
    this.items[this.writePos % this.size] = [curTime, item];
    this.writePos += 1;
    if (this.head === this.writePos) {
      this.head += 1;
    }
    const minTime = curTime - this.timeout * 1e3;
    let atItem;
    while (this.head < this.writePos) {
      atItem = this.items[this.head % this.size];
      if (atItem === void 0)
        break;
      if (atItem[0] > minTime)
        break;
      this.head += 1;
    }
  }
  subscribe(callback) {
    const readerId = generateUuidv4();
    this.readers.set(readerId, callback);
    setTimeout(() => this.stream(readerId));
    return readerId;
  }
  unsubscribe(readerId) {
    this.readers.delete(readerId);
  }
  stream(readerId, readPos = this.head) {
    const cb = this.readers.get(readerId);
    if (!cb)
      return;
    let atReadPos = readPos;
    let item;
    while (true) {
      item = this.items[atReadPos % this.size];
      if (typeof item === "undefined" || atReadPos >= this.writePos) {
        break;
      }
      cb(item[1]);
      atReadPos += 1;
    }
    setTimeout(() => this.stream(readerId, atReadPos), 500);
  }
  clear() {
    this.items = new Array(this.size);
    this.writePos = 0;
    this.head = 0;
    this.readers = /* @__PURE__ */ new Map();
  }
}
function generateUuidv4() {
  let dt = (/* @__PURE__ */ new Date()).getTime();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    let rnd = Math.random() * 16;
    rnd = (dt + rnd) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c === "x" ? rnd : rnd & 3 | 8).toString(16);
  });
}
const DEFAULT_PORT = 8969;
const SERVER_IDENTIFIER = "spotlight-by-sentry";
function getCorsHeader() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Credentials": "true",
    "Access-Control-Allow-Headers": "*",
    "Access-Control-Allow-Methods": "GET,POST,PUT,OPTIONS,DELETE,PATCH"
  };
}
function getSpotlightHeader() {
  return {
    "X-Powered-by": SERVER_IDENTIFIER
  };
}
function handleStreamRequest(req, res, buffer2, incomingPayload) {
  if (req.headers.accept && req.headers.accept == "text/event-stream") {
    if (req.url == "/stream") {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        ...getCorsHeader(),
        ...getSpotlightHeader(),
        Connection: "keep-alive"
      });
      res.flushHeaders();
      const sub = buffer2.subscribe(([payloadType, data]) => {
        logger.debug(`ðŸ•Šï¸ sending to Spotlight`);
        res.write(`event:${payloadType}
`);
        data.split("\n").forEach((line) => {
          res.write(`data:${line}
`);
        });
        res.write("\n");
      });
      req.on("close", () => {
        buffer2.unsubscribe(sub);
        res.end();
      });
    } else {
      res.writeHead(404);
      res.end();
    }
    return true;
  } else {
    if (req.url == "/stream") {
      if (req.method === "OPTIONS") {
        res.writeHead(204, {
          "Cache-Control": "no-cache",
          ...getCorsHeader(),
          ...getSpotlightHeader()
        });
        res.end();
      } else if (req.method === "POST") {
        logger.debug(`ðŸ“© Received event`);
        let body = "";
        let stream = req;
        const encoding = req.headers["content-encoding"];
        if (encoding === "gzip") {
          stream = req.pipe(createGunzip());
        } else if (encoding === "deflate") {
          stream = req.pipe(createInflate());
        }
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            body += chunk;
          }
        });
        stream.on("end", () => {
          buffer2.put([`${req.headers["content-type"]}`, body]);
          if (process.env.SPOTLIGHT_CAPTURE || incomingPayload) {
            const timestamp = (/* @__PURE__ */ new Date()).getTime();
            const contentType = `${req.headers["content-type"]}`;
            const filename = `${contentType.replace(/[^a-z0-9]/gi, "_").toLowerCase()}-${timestamp}.txt`;
            if (incomingPayload) {
              incomingPayload(body);
            } else {
              createWriteStream(filename).write(body);
              logger.info(`ðŸ—ƒï¸ Saved data to ${filename}`);
            }
          }
          res.writeHead(200, {
            "Cache-Control": "no-cache",
            ...getCorsHeader(),
            ...getSpotlightHeader(),
            Connection: "keep-alive"
          });
          res.end();
        });
      }
      return true;
    }
  }
  return false;
}
function serveFile(req, res, basePath) {
  let filePath = "." + req.url;
  if (filePath == "./") {
    filePath = "./src/index.html";
  }
  const extName = extname(filePath);
  let contentType = "text/html";
  switch (extName) {
    case ".js":
      contentType = "text/javascript";
      break;
    case ".css":
      contentType = "text/css";
      break;
    case ".json":
      contentType = "application/json";
      break;
  }
  readFile(join(basePath, filePath), function(error, content) {
    if (error) {
      res.writeHead(404);
      res.end();
    } else {
      res.writeHead(200, { "Content-Type": contentType });
      res.end(content, "utf-8");
    }
  });
}
function startServer(buffer2, port, basePath, incomingPayload) {
  const server = createServer(handleRequest);
  server.on("error", handleServerError);
  server.listen(port, () => {
    handleServerListen(port, basePath);
  });
  return server;
  function handleRequest(req, res) {
    if (req.url === "/health") {
      handleHealthRequest(res);
    } else if (req.url === "/clear") {
      handleClearRequest(req, res);
    } else {
      handleOtherRequest(req, res);
    }
  }
  function handleHealthRequest(res) {
    res.writeHead(200, {
      "Content-Type": "text/plain",
      ...getCorsHeader(),
      ...getSpotlightHeader()
    });
    res.end("OK");
  }
  function handleClearRequest(req, res) {
    if (req.method === "OPTIONS") {
      res.writeHead(204, {
        "Cache-Control": "no-cache",
        ...getCorsHeader(),
        ...getSpotlightHeader()
      });
      res.end();
    } else if (req.method === "DELETE") {
      res.writeHead(200, {
        "Content-Type": "text/plain",
        ...getCorsHeader(),
        ...getSpotlightHeader()
      });
      clearBuffer();
      res.end("Cleared");
    }
  }
  function handleOtherRequest(req, res) {
    const handled = handleStreamRequest(req, res, buffer2, incomingPayload);
    if (!handled && basePath) {
      serveFile(req, res, basePath);
    }
    if (!handled && !basePath) {
      res.writeHead(404);
      res.end();
    }
  }
  function handleServerError(e) {
    if ("code" in e && e.code === "EADDRINUSE") {
      logger.info(`Port ${port} in use, retrying...`);
      setTimeout(() => {
        server.close();
        server.listen(port);
        logger.info(`Port ${port} in use, retrying...`);
      }, 5e3);
    }
  }
  function handleServerListen(port2, basePath2) {
    logger.info(`Sidecar listening on ${port2}`);
    if (basePath2) {
      logger.info(`You can open: http://localhost:${port2} to see the Spotlight overlay directly`);
    }
  }
}
let serverInstance;
const buffer = new MessageBuffer();
const isValidPort = (value) => {
  if (typeof value === "string") {
    const portNumber = Number(value);
    return /^\d+$/.test(value) && portNumber > 0 && portNumber <= 65535;
  }
  return value > 0 && value <= 65535;
};
function isSidecarRunning(port) {
  return new Promise((resolve) => {
    const options = {
      hostname: "localhost",
      port,
      path: "/health",
      method: "GET",
      timeout: 5e3
    };
    const healthReq = get(options, (res) => {
      const serverIdentifier = res.headers["x-powered-by"];
      if (serverIdentifier === "spotlight-by-sentry") {
        resolve(true);
      } else {
        resolve(false);
      }
    });
    healthReq.on("error", () => {
      resolve(false);
    });
  });
}
function setupSidecar({
  port,
  logger: customLogger,
  basePath,
  debug,
  incomingPayload
} = {}) {
  let sidecarPort = DEFAULT_PORT;
  if (customLogger) {
    activateLogger(customLogger);
  }
  if (debug || process.env.SPOTLIGHT_DEBUG) {
    enableDebugLogging(true);
  }
  if (port && !isValidPort(port)) {
    logger.info("Please provide a valid port.");
    process.exit(1);
  } else if (port) {
    sidecarPort = typeof port === "string" ? Number(port) : port;
  }
  isSidecarRunning(sidecarPort).then((isRunning) => {
    if (isRunning) {
      logger.info(`Sidecar is already running on port ${sidecarPort}`);
    } else {
      if (!serverInstance) {
        serverInstance = startServer(buffer, sidecarPort, basePath, incomingPayload);
      }
    }
  });
}
function clearBuffer() {
  buffer.clear();
}
function shutdown() {
  if (serverInstance) {
    logger.info("Shutting down Server");
    serverInstance.close();
  }
}
process.on("SIGTERM", () => {
  shutdown();
});
export {
  clearBuffer,
  setupSidecar,
  shutdown
};
//# sourceMappingURL=main.js.map
