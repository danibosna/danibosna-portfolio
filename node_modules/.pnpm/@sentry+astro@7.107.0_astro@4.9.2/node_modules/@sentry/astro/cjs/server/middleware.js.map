{"version":3,"file":"middleware.js","sources":["../../../src/server/middleware.ts"],"sourcesContent":["import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, setHttpStatus } from '@sentry/core';\nimport {\n  captureException,\n  continueTrace,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  runWithAsyncContext,\n  startSpan,\n} from '@sentry/node';\nimport type { Client, Scope, Span } from '@sentry/types';\nimport { addNonEnumerableProperty, objectify, stripUrlQueryAndFragment } from '@sentry/utils';\nimport type { APIContext, MiddlewareResponseHandler } from 'astro';\n\nimport { getTracingMetaTags } from './meta';\n\ntype MiddlewareOptions = {\n  /**\n   * If true, the client IP will be attached to the event by calling `setUser`.\n   *\n   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR\n   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.\n   * Otherwise, Astro will throw an error when starting the server.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackClientIp?: boolean;\n\n  /**\n   * If true, the headers from the request will be attached to the event by calling `setExtra`.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackHeaders?: boolean;\n};\n\nfunction sendErrorToSentry(e: unknown): unknown {\n  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n  // store a seen flag on it.\n  const objectifiedErr = objectify(e);\n\n  captureException(objectifiedErr, {\n    mechanism: {\n      type: 'astro',\n      handled: false,\n      data: {\n        function: 'astroMiddleware',\n      },\n    },\n  });\n\n  return objectifiedErr;\n}\n\ntype AstroLocalsWithSentry = Record<string, unknown> & {\n  __sentry_wrapped__?: boolean;\n};\n\nexport const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {\n  const handlerOptions = {\n    trackClientIp: false,\n    trackHeaders: false,\n    ...options,\n  };\n\n  return async (ctx, next) => {\n    // if there is an active span, we know that this handle call is nested and hence\n    // we don't create a new domain for it. If we created one, nested server calls would\n    // create new transactions instead of adding a child span to the currently active span.\n    if (getActiveSpan()) {\n      return instrumentRequest(ctx, next, handlerOptions);\n    }\n    return runWithAsyncContext(() => {\n      return instrumentRequest(ctx, next, handlerOptions);\n    });\n  };\n};\n\nasync function instrumentRequest(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n  options: MiddlewareOptions,\n): Promise<Response> {\n  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)\n  const locals = ctx.locals as AstroLocalsWithSentry;\n  if (locals && locals.__sentry_wrapped__) {\n    return next();\n  }\n  addNonEnumerableProperty(locals, '__sentry_wrapped__', true);\n\n  const { method, headers } = ctx.request;\n\n  return continueTrace(\n    {\n      sentryTrace: headers.get('sentry-trace') || undefined,\n      baggage: headers.get('baggage'),\n    },\n    async () => {\n      const allHeaders: Record<string, string> = {};\n\n      if (options.trackHeaders) {\n        headers.forEach((value, key) => {\n          allHeaders[key] = value;\n        });\n      }\n\n      if (options.trackClientIp) {\n        getCurrentScope().setUser({ ip_address: ctx.clientAddress });\n      }\n\n      try {\n        const interpolatedRoute = interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params);\n        const source = interpolatedRoute ? 'route' : 'url';\n        // storing res in a variable instead of directly returning is necessary to\n        // invoke the catch block if next() throws\n        const res = await startSpan(\n          {\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',\n            },\n            name: `${method} ${interpolatedRoute || ctx.url.pathname}`,\n            op: 'http.server',\n            status: 'ok',\n            data: {\n              method,\n              url: stripUrlQueryAndFragment(ctx.url.href),\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n              ...(ctx.url.search && { 'http.query': ctx.url.search }),\n              ...(ctx.url.hash && { 'http.fragment': ctx.url.hash }),\n              ...(options.trackHeaders && { headers: allHeaders }),\n            },\n          },\n          async span => {\n            const originalResponse = await next();\n\n            if (span && originalResponse.status) {\n              setHttpStatus(span, originalResponse.status);\n            }\n\n            const scope = getCurrentScope();\n            const client = getClient();\n            const contentType = originalResponse.headers.get('content-type');\n\n            const isPageloadRequest = contentType && contentType.startsWith('text/html');\n            if (!isPageloadRequest || !client) {\n              return originalResponse;\n            }\n\n            // Type case necessary b/c the body's ReadableStream type doesn't include\n            // the async iterator that is actually available in Node\n            // We later on use the async iterator to read the body chunks\n            // see https://github.com/microsoft/TypeScript/issues/39051\n            const originalBody = originalResponse.body as NodeJS.ReadableStream | null;\n            if (!originalBody) {\n              return originalResponse;\n            }\n\n            const decoder = new TextDecoder();\n\n            const newResponseStream = new ReadableStream({\n              start: async controller => {\n                for await (const chunk of originalBody) {\n                  const html = typeof chunk === 'string' ? chunk : decoder.decode(chunk, { stream: true });\n                  const modifiedHtml = addMetaTagToHead(html, scope, client, span);\n                  controller.enqueue(new TextEncoder().encode(modifiedHtml));\n                }\n                controller.close();\n              },\n            });\n\n            return new Response(newResponseStream, originalResponse);\n          },\n        );\n        return res;\n      } catch (e) {\n        sendErrorToSentry(e);\n        throw e;\n      }\n      // TODO: flush if serverless (first extract function)\n    },\n  );\n}\n\n/**\n * This function optimistically assumes that the HTML coming in chunks will not be split\n * within the <head> tag. If this still happens, we simply won't replace anything.\n */\nfunction addMetaTagToHead(htmlChunk: string, scope: Scope, client: Client, span?: Span): string {\n  if (typeof htmlChunk !== 'string') {\n    return htmlChunk;\n  }\n\n  const { sentryTrace, baggage } = getTracingMetaTags(span, scope, client);\n  const content = `<head>\\n${sentryTrace}\\n${baggage}\\n`;\n  return htmlChunk.replace('<head>', content);\n}\n\n/**\n * Interpolates the route from the URL and the passed params.\n * Best we can do to get a route name instead of a raw URL.\n *\n * exported for testing\n *\n * @param rawUrlPathname - The raw URL pathname, e.g. '/users/123/details'\n * @param params - The params object, e.g. `{ userId: '123' }`\n *\n * @returns The interpolated route, e.g. '/users/[userId]/details'\n */\nexport function interpolateRouteFromUrlAndParams(\n  rawUrlPathname: string,\n  params: APIContext['params'],\n): string | undefined {\n  const decodedUrlPathname = tryDecodeUrl(rawUrlPathname);\n  if (!decodedUrlPathname) {\n    return undefined;\n  }\n\n  // Invert params map so that the param values are the keys\n  // differentiate between rest params spanning multiple url segments\n  // and normal, single-segment params.\n  const valuesToMultiSegmentParams: Record<string, string> = {};\n  const valuesToParams: Record<string, string> = {};\n  Object.entries(params).forEach(([key, value]) => {\n    if (!value) {\n      return;\n    }\n    if (value.includes('/')) {\n      valuesToMultiSegmentParams[value] = key;\n      return;\n    }\n    valuesToParams[value] = key;\n  });\n\n  function replaceWithParamName(segment: string): string {\n    const param = valuesToParams[segment];\n    if (param) {\n      return `[${param}]`;\n    }\n    return segment;\n  }\n\n  // before we match single-segment params, we first replace multi-segment params\n  const urlWithReplacedMultiSegmentParams = Object.keys(valuesToMultiSegmentParams).reduce((acc, key) => {\n    return acc.replace(key, `[${valuesToMultiSegmentParams[key]}]`);\n  }, decodedUrlPathname);\n\n  return urlWithReplacedMultiSegmentParams\n    .split('/')\n    .map(segment => {\n      if (!segment) {\n        return '';\n      }\n\n      if (valuesToParams[segment]) {\n        return replaceWithParamName(segment);\n      }\n\n      // astro permits multiple params in a single path segment, e.g. /[foo]-[bar]/\n      const segmentParts = segment.split('-');\n      if (segmentParts.length > 1) {\n        return segmentParts.map(part => replaceWithParamName(part)).join('-');\n      }\n\n      return segment;\n    })\n    .join('/');\n}\n\nfunction tryDecodeUrl(url: string): string | undefined {\n  try {\n    return decodeURI(url);\n  } catch {\n    return undefined;\n  }\n}\n"],"names":["objectify","captureException","getActiveSpan","runWithAsyncContext","addNonEnumerableProperty","continueTrace","getCurrentScope","startSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","stripUrlQueryAndFragment","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","setHttpStatus","getClient","getTracingMetaTags"],"mappings":"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"}